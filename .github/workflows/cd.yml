name: CD Pipeline

on:
  workflow_run:
    workflows: ['CI Pipeline']
    types:
      - completed
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DEPLOY_PATH: /opt/media-archive/archive

jobs:
  # –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ CI –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Verify CI passed
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "‚ùå CI Pipeline did not pass. Deployment cancelled."
            exit 1
          fi
          echo "‚úÖ CI Pipeline passed. Proceeding with deployment."

  # –î–µ–ø–ª–æ–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: check-ci
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Set default SSH port
        id: ssh_port
        run: |
          if [ -z "${{ secrets.VPS_SSH_PORT }}" ]; then
            echo "port=22" >> $GITHUB_OUTPUT
          else
            echo "port=${{ secrets.VPS_SSH_PORT }}" >> $GITHUB_OUTPUT
          fi

      - name: Set default URLs
        id: urls
        run: |
          API_URL="${{ secrets.API_BASE_URL }}"
          FRONTEND_URL="${{ secrets.FRONTEND_URL }}"
          if [ -z "$API_URL" ]; then
            echo "api_url=http://localhost:4000" >> $GITHUB_OUTPUT
          else
            echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          fi
          if [ -z "$FRONTEND_URL" ]; then
            echo "frontend_url=http://localhost:8080" >> $GITHUB_OUTPUT
          else
            echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          fi

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ steps.ssh_port.outputs.port }} -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Display deployment info
        run: |
          echo "üöÄ Starting deployment..."
          echo "üì¶ Branch: ${{ github.ref_name }}"
          echo "üîñ Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üåê Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "üìç Server: ${{ secrets.VPS_HOST }}"

      - name: Deploy to server
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST << ENDSSH
            set -e
            echo "üìÇ Navigating to project directory..."
            cd $DEPLOY_PATH || { echo "‚ùå Directory not found: $DEPLOY_PATH"; exit 1; }

            echo "üì• Fetching latest changes..."
            git fetch origin

            echo "üîÑ Checking out branch: ${{ github.ref_name }}"
            BRANCH_NAME="${{ github.ref_name }}"
            git checkout \$BRANCH_NAME || git checkout -b \$BRANCH_NAME origin/\$BRANCH_NAME

            echo "‚¨áÔ∏è Pulling latest code..."
            git pull origin \$BRANCH_NAME

            echo "üìã Current commit: $(git rev-parse HEAD)"
            echo "üìù Commit message: $(git log -1 --pretty=%B)"

            echo "üìä Checking disk space..."
            df -h / || true
            df -h /var/lib/docker || true

            echo "üîß Checking Docker daemon status..."
            docker info > /dev/null 2>&1 || {
              echo "‚ö†Ô∏è Docker daemon issue detected, attempting to restart..."
              sudo systemctl restart docker || true
              sleep 5
            }

            echo "üî® Building new images (old containers continue running)..."
            echo "‚è±Ô∏è This may take several minutes, especially on first build..."
            # –°–æ–±–∏—Ä–∞–µ–º –Ω–æ–≤—ã–µ –æ–±—Ä–∞–∑—ã –ë–ï–ó –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—Ç–∞—Ä—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ –¥–ª—è zero-downtime
            MAX_BUILD_RETRIES=3
            BUILD_RETRY=0
            BUILD_TIMEOUT=1800  # 30 –º–∏–Ω—É—Ç —Ç–∞–π–º–∞—É—Ç –¥–ª—è —Å–±–æ—Ä–∫–∏
            
            while [ $BUILD_RETRY -lt $MAX_BUILD_RETRIES ]; do
              echo "üî® Build attempt $((BUILD_RETRY + 1))/$MAX_BUILD_RETRIES"
              
              # –°–æ–±–∏—Ä–∞–µ–º —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ –≤—ã–≤–æ–¥–æ–º –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
              # –ò—Å–ø–æ–ª—å–∑—É–µ–º timeout –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω, –∏–Ω–∞—á–µ –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä–∫—É
              if command -v timeout >/dev/null 2>&1; then
                echo "‚è±Ô∏è Using timeout: $BUILD_TIMEOUT seconds"
                if timeout $BUILD_TIMEOUT docker compose -f docker-compose.prod.yml build --pull --progress=plain; then
                  BUILD_SUCCESS=1
                else
                  BUILD_EXIT_CODE=$?
                  BUILD_SUCCESS=0
                  if [ $BUILD_EXIT_CODE -eq 124 ]; then
                    echo "‚è±Ô∏è Build timed out after $BUILD_TIMEOUT seconds"
                  else
                    echo "‚ùå Build failed with exit code $BUILD_EXIT_CODE"
                  fi
                fi
              else
                # –ï—Å–ª–∏ timeout –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä–∫—É
                echo "‚ö†Ô∏è timeout command not available, building without timeout"
                if docker compose -f docker-compose.prod.yml build --pull --progress=plain; then
                  BUILD_SUCCESS=1
                else
                  BUILD_SUCCESS=0
                  echo "‚ùå Build failed"
                fi
              fi
              
              if [ "$BUILD_SUCCESS" -eq 1 ]; then
                echo "‚úÖ Build successful"
                break
              else
                BUILD_RETRY=$((BUILD_RETRY + 1))
                if [ $BUILD_RETRY -lt $MAX_BUILD_RETRIES ]; then
                  echo "‚ö†Ô∏è Build failed, retrying... ($BUILD_RETRY/$MAX_BUILD_RETRIES)"
                  sleep 10
                else
                  echo "‚ùå Build failed after $MAX_BUILD_RETRIES attempts"
                  echo "üìã Checking Docker status:"
                  docker compose -f docker-compose.prod.yml ps || true
                  docker compose -f docker-compose.prod.yml logs --tail=50 || true
                  exit 1
                fi
              fi
            done

            echo "üîÑ Rolling update: Updating server (zero-downtime)..."
            # –û–±–Ω–æ–≤–ª—è–µ–º server —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π health - —Å—Ç–∞—Ä—ã–π –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –ø–æ–∫–∞ –Ω–æ–≤—ã–π –Ω–µ —Å—Ç–∞–Ω–µ—Ç healthy
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º --force-recreate —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∏–º—è –∑–∞–Ω—è—Ç–æ
            if ! docker compose -f docker-compose.prod.yml up -d --no-deps --remove-orphans --force-recreate server; then
              echo "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ server"
              docker compose -f docker-compose.prod.yml logs server --tail=50
              exit 1
            fi

            echo "‚è≥ Waiting for new server to be healthy..."
            # –î–∞–µ–º –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä—É –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è
            sleep 5

            MAX_HEALTH_RETRIES=40
            HEALTH_RETRY=0
            SERVER_HEALTHY=0
            while [ $HEALTH_RETRY -lt $MAX_HEALTH_RETRIES ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ health endpoint (–æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
              if curl -f -s http://localhost:4000/api/health > /dev/null 2>&1; then
                echo "‚úÖ New server is healthy (attempt $((HEALTH_RETRY + 1)))"
                SERVER_HEALTHY=1
                break
              fi
              HEALTH_RETRY=$((HEALTH_RETRY + 1))
              if [ $((HEALTH_RETRY % 5)) -eq 0 ]; then
                echo "‚è≥ Waiting for server health... ($HEALTH_RETRY/$MAX_HEALTH_RETRIES)"
                echo "üìä Server status:"
                docker compose -f docker-compose.prod.yml ps server 2>/dev/null || echo "‚ö†Ô∏è Could not get server status"
              fi
              sleep 2 || true
            done

            if [ $SERVER_HEALTHY -eq 0 ]; then
              echo "‚ùå New server failed to become healthy after $MAX_HEALTH_RETRIES attempts"
              echo "üìã Server logs:"
              docker compose -f docker-compose.prod.yml logs server --tail=50
              echo "üìä Server status:"
              docker compose -f docker-compose.prod.yml ps server
              echo "üîç Testing health endpoint directly:"
              curl -v http://localhost:4000/api/health || true
              exit 1
            fi

            echo "üîÑ Rolling update: Updating client..."
            # –û–±–Ω–æ–≤–ª—è–µ–º client –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ server –≥–æ—Ç–æ–≤
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º --force-recreate —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∏–º—è –∑–∞–Ω—è—Ç–æ
            docker compose -f docker-compose.prod.yml up -d --no-deps --remove-orphans --force-recreate client || {
              echo "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ client"
              docker compose -f docker-compose.prod.yml logs client --tail=50
              exit 1
            }

            echo "‚è≥ Waiting for new client to be ready..."
            sleep 5

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ client –¥–æ—Å—Ç—É–ø–µ–Ω
            if curl -f -s http://localhost:8080/ > /dev/null 2>&1; then
              echo "‚úÖ Client is ready"
            else
              echo "‚ö†Ô∏è Client health check failed, but continuing (non-critical)"
            fi

            echo "üßπ Cleaning up old images (after successful deployment)..."
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±—Ä–∞–∑—ã —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –¥–µ–ø–ª–æ—è
            docker image prune -f || true

            echo "‚úÖ Zero-downtime deployment completed successfully"

            # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ)
            echo "üìä Final service status:"
            docker compose -f docker-compose.prod.yml ps || echo "‚ö†Ô∏è Could not get final status"

            echo "üéâ Deployment successful!"
          ENDSSH

      - name: Health check
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          API_URL: ${{ steps.urls.outputs.api_url }}
          FRONTEND_URL: ${{ steps.urls.outputs.frontend_url }}
        run: |
          echo "üè• Performing health checks..."

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST bash -s << ENDSSH || true
            set -e
            DEPLOY_PATH="$DEPLOY_PATH"
            echo "üìÇ Navigating to project directory..."
            cd "\$DEPLOY_PATH" || { echo "‚ùå Directory not found: \$DEPLOY_PATH"; exit 1; }

            echo "üìä Container status:"
            docker compose -f docker-compose.prod.yml ps || true

            echo "üîç Checking container health..."
            MAX_RETRIES=15
            RETRY_COUNT=0
            CONTAINERS_HEALTHY=0

            while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã —Å—É—â–µ—Å—Ç–≤—É—é—Ç –∏ –∑–∞–ø—É—â–µ–Ω—ã
              SERVER_RUNNING=\$(docker compose -f docker-compose.prod.yml ps server 2>/dev/null | grep -c "server" || echo "0")
              CLIENT_RUNNING=\$(docker compose -f docker-compose.prod.yml ps client 2>/dev/null | grep -c "client" || echo "0")
              POSTGRES_RUNNING=\$(docker compose -f docker-compose.prod.yml ps postgres 2>/dev/null | grep -c "postgres" || echo "0")

              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ docker ps (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ)
              SERVER_UP=\$(docker compose -f docker-compose.prod.yml ps server 2>/dev/null | tail -n +2 | grep -iE "running|up|healthy" | wc -l || echo "0")
              CLIENT_UP=\$(docker compose -f docker-compose.prod.yml ps client 2>/dev/null | tail -n +2 | grep -iE "running|up|healthy" | wc -l || echo "0")
              POSTGRES_UP=\$(docker compose -f docker-compose.prod.yml ps postgres 2>/dev/null | tail -n +2 | grep -iE "running|up|healthy" | wc -l || echo "0")

              echo "üìä Server: \$SERVER_UP, Client: \$CLIENT_UP, Postgres: \$POSTGRES_UP"

              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –∑–∞–ø—É—â–µ–Ω—ã
              if [ "\$SERVER_UP" -gt 0 ] && [ "\$CLIENT_UP" -gt 0 ] && [ "\$POSTGRES_UP" -gt 0 ]; then
                echo "‚úÖ All containers are running"
                CONTAINERS_HEALTHY=1
                break
              fi

              RETRY_COUNT=\$((RETRY_COUNT + 1))
              if [ \$((RETRY_COUNT % 3)) -eq 0 ]; then
                echo "‚è≥ Waiting for containers... (\$RETRY_COUNT/\$MAX_RETRIES)"
                echo "üìã Recent logs:"
                docker compose -f docker-compose.prod.yml logs --tail=20 server 2>/dev/null || true
              fi
              sleep 3
            done

            if [ \$CONTAINERS_HEALTHY -eq 0 ]; then
              echo "‚ö†Ô∏è Some containers may not be fully healthy, but continuing..."
              echo "üìã Full container status:"
              docker compose -f docker-compose.prod.yml ps || true
              echo "üìã Recent logs:"
              docker compose -f docker-compose.prod.yml logs --tail=50 || true
            fi
          ENDSSH

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ API —á–µ—Ä–µ–∑ SSH (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ —á–µ–º —Å–Ω–∞—Ä—É–∂–∏)
          echo "üîå Checking API health endpoint..."
          API_HEALTH_URL="${API_URL}/api/health"
          MAX_RETRIES=20
          RETRY_COUNT=0
          API_HEALTHY=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ SSH –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ (localhost –¥–æ—Å—Ç—É–ø–µ–Ω)
            if ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST "curl -f -s http://localhost:4000/api/health > /dev/null 2>&1"; then
              echo "‚úÖ API health check passed (internal)"
              API_RESPONSE=$(ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST "curl -s http://localhost:4000/api/health" 2>/dev/null || echo "")
              echo "üìã API response: $API_RESPONSE"
              API_HEALTHY=1
              break
            fi

            # –¢–∞–∫–∂–µ –ø—Ä–æ–±—É–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–∞—Ä—É–∂–∏ (–µ—Å–ª–∏ API –¥–æ—Å—Ç—É–ø–µ–Ω –ø—É–±–ª–∏—á–Ω–æ)
            if [ -n "$API_URL" ] && [ "$API_URL" != "http://localhost:4000" ]; then
              if curl -f -s --max-time 5 "$API_HEALTH_URL" > /dev/null 2>&1; then
                echo "‚úÖ API health check passed (external)"
                API_RESPONSE=$(curl -s --max-time 5 "$API_HEALTH_URL" 2>/dev/null || echo "")
                echo "üìã API response: $API_RESPONSE"
                API_HEALTHY=1
                break
              fi
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
              echo "‚è≥ Waiting for API... ($RETRY_COUNT/$MAX_RETRIES)"
              echo "üîç Testing connection:"
              ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST "cd $DEPLOY_PATH && docker compose -f docker-compose.prod.yml ps server || true" || true
            fi
            sleep 3
          done

          if [ $API_HEALTHY -eq 0 ]; then
            echo "‚ö†Ô∏è API health check failed, but deployment may still be successful"
            echo "üìã Server logs:"
            ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST "cd $DEPLOY_PATH && docker compose -f docker-compose.prod.yml logs server --tail=30" || true
            # –ù–µ –∑–∞–≤–µ—Ä—à–∞–µ–º —Å –æ—à–∏–±–∫–æ–π, —Ç–∞–∫ –∫–∞–∫ —Å–µ—Ä–≤–µ—Ä –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ
          fi

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
          echo "üåê Checking frontend..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          FRONTEND_ACCESSIBLE=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ SSH –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
            if ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST "curl -f -s http://localhost:8080/ > /dev/null 2>&1"; then
              echo "‚úÖ Frontend is accessible (internal)"
              FRONTEND_ACCESSIBLE=1
              break
            fi

            # –¢–∞–∫–∂–µ –ø—Ä–æ–±—É–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–Ω–∞—Ä—É–∂–∏
            if [ -n "$FRONTEND_URL" ] && [ "$FRONTEND_URL" != "http://localhost:8080" ]; then
              if curl -f -s --max-time 5 "$FRONTEND_URL" > /dev/null 2>&1; then
                echo "‚úÖ Frontend is accessible (external)"
                FRONTEND_ACCESSIBLE=1
                break
              fi
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $((RETRY_COUNT % 3)) -eq 0 ]; then
              echo "‚è≥ Waiting for frontend... ($RETRY_COUNT/$MAX_RETRIES)"
            fi
            sleep 3
          done

          if [ $FRONTEND_ACCESSIBLE -eq 0 ]; then
            echo "‚ö†Ô∏è Frontend check failed (non-critical)"
          fi

          echo "‚úÖ Health checks completed"

      - name: Deployment summary
        if: always()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Author** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Time** | $(date -u +'%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ **Deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üåê **Frontend**: ${{ steps.urls.outputs.frontend_url }}" >> $GITHUB_STEP_SUMMARY
            echo "üîå **API**: ${{ steps.urls.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Rollback on failure
        if: failure()
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          echo "‚ö†Ô∏è Deployment failed. Attempting rollback..."
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST << ENDSSH || true
            set -e
            cd $DEPLOY_PATH || { echo "‚ùå Directory not found: $DEPLOY_PATH"; exit 1; }
            echo "üîÑ Rolling back to previous commit..."
            git reset --hard HEAD~1 || git reset --hard origin/${{ github.ref_name }} || true
            echo "üî® Rebuilding containers..."
            docker compose -f docker-compose.prod.yml up -d --build || true
            echo "‚úÖ Rollback completed"
          ENDSSH

  # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Set default URLs
        id: urls
        run: |
          API_URL="${{ secrets.API_BASE_URL }}"
          if [ -z "$API_URL" ]; then
            echo "api_url=http://localhost:4000" >> $GITHUB_OUTPUT
          else
            echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          fi

      - name: Calculate deployment duration
        id: duration
        run: |
          # –ü–æ–ª—É—á–∞–µ–º –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –¥–µ–ø–ª–æ—è –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ job
          # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å, –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç—ã–º
          echo "duration=" >> $GITHUB_OUTPUT

      - name: Send Telegram notification
        env:
          API_URL: ${{ steps.urls.outputs.api_url }}
          DEPLOY_SECRET: ${{ secrets.TELEGRAM_DEPLOY_SECRET }}
        run: |
          DEPLOY_RESULT="${{ needs.deploy.result }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'production' }}"

          if [ -z "$DEPLOY_SECRET" ]; then
            echo "‚ö†Ô∏è TELEGRAM_DEPLOY_SECRET is not set. Skipping Telegram notification."
            exit 0
          fi

          if [ -z "$API_URL" ]; then
            echo "‚ö†Ô∏è API_BASE_URL is not set. Skipping Telegram notification."
            exit 0
          fi

          # –ú–∞–ø–ø–∏–º —Å—Ç–∞—Ç—É—Å –¥–µ–ø–ª–æ—è –Ω–∞ —Ñ–æ—Ä–º–∞—Ç, –æ–∂–∏–¥–∞–µ–º—ã–π API
          if [ "$DEPLOY_RESULT" == "success" ]; then
            STATUS="success"
          else
            # failure, cancelled, skipped - –≤—Å–µ —Å—á–∏—Ç–∞–µ–º failure
            STATUS="failure"
          fi

          echo "üì§ Sending Telegram notification: status=$STATUS, environment=$ENVIRONMENT"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
          if ! curl -f -s --max-time 5 "$API_URL/api/health" > /dev/null 2>&1; then
            echo "‚ö†Ô∏è API is not accessible at $API_URL. Skipping Telegram notification."
            exit 0
          fi

          # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ API
          curl -X POST "$API_URL/api/telegram/deploy" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $DEPLOY_SECRET" \
            -d "{
              \"status\": \"$STATUS\",
              \"branch\": \"${{ github.ref_name }}\",
              \"commit\": \"${{ github.sha }}\",
              \"author\": \"${{ github.actor }}\",
              \"environment\": \"$ENVIRONMENT\"
            }" \
            --fail-with-body \
            --silent \
            --show-error || echo "‚ö†Ô∏è Failed to send Telegram notification (non-critical)"
