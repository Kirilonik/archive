name: CD Pipeline

on:
  workflow_run:
    workflows: ['CI Pipeline']
    types:
      - completed
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  DEPLOY_PATH: /opt/media-archive/archive

jobs:
  # –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ CI –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Verify CI passed
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "‚ùå CI Pipeline did not pass. Deployment cancelled."
            exit 1
          fi
          echo "‚úÖ CI Pipeline passed. Proceeding with deployment."

  # –î–µ–ø–ª–æ–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: check-ci
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Set default SSH port
        id: ssh_port
        run: |
          if [ -z "${{ secrets.VPS_SSH_PORT }}" ]; then
            echo "port=22" >> $GITHUB_OUTPUT
          else
            echo "port=${{ secrets.VPS_SSH_PORT }}" >> $GITHUB_OUTPUT
          fi

      - name: Set default URLs
        id: urls
        run: |
          API_URL="${{ secrets.API_BASE_URL }}"
          FRONTEND_URL="${{ secrets.FRONTEND_URL }}"
          if [ -z "$API_URL" ]; then
            echo "api_url=http://localhost:4000" >> $GITHUB_OUTPUT
          else
            echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          fi
          if [ -z "$FRONTEND_URL" ]; then
            echo "frontend_url=http://localhost:8080" >> $GITHUB_OUTPUT
          else
            echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          fi

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ steps.ssh_port.outputs.port }} -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Display deployment info
        run: |
          echo "üöÄ Starting deployment..."
          echo "üì¶ Branch: ${{ github.ref_name }}"
          echo "üîñ Commit: ${{ github.sha }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo "üåê Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "üìç Server: ${{ secrets.VPS_HOST }}"

      - name: Deploy to server
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
        run: |
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST << 'ENDSSH'
            set -e
            echo "üìÇ Navigating to project directory..."
            cd ${{ env.DEPLOY_PATH }} || { echo "‚ùå Directory not found: ${{ env.DEPLOY_PATH }}"; exit 1; }
            
            echo "üì• Fetching latest changes..."
            git fetch origin
            
            echo "üîÑ Checking out branch: ${{ github.ref_name }}"
            git checkout ${{ github.ref_name }} || git checkout -b ${{ github.ref_name }} origin/${{ github.ref_name }}
            
            echo "‚¨áÔ∏è Pulling latest code..."
            git pull origin ${{ github.ref_name }}
            
            echo "üìã Current commit: $(git rev-parse HEAD)"
            echo "üìù Commit message: $(git log -1 --pretty=%B)"
            
            echo "üê≥ Stopping existing containers..."
            docker compose -f docker-compose.prod.yml down || true
            
            echo "üßπ Cleaning up old images..."
            docker system prune -af --volumes || true
            
            echo "üî® Building and starting containers..."
            docker compose -f docker-compose.prod.yml build --no-cache
            
            echo "üöÄ Starting services..."
            docker compose -f docker-compose.prod.yml up -d
            
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 10
          ENDSSH

      - name: Health check
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
          API_URL: ${{ steps.urls.outputs.api_url }}
          FRONTEND_URL: ${{ steps.urls.outputs.frontend_url }}
        run: |
          echo "üè• Performing health checks..."

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST << 'ENDSSH'
            echo "üìä Container status:"
            docker compose -f docker-compose.prod.yml ps
            
            echo "üîç Checking container health..."
            MAX_RETRIES=10
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker compose -f docker-compose.prod.yml ps | grep -q "healthy\|Up"; then
                echo "‚úÖ Containers are running"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚è≥ Waiting for containers... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 5
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Containers failed to start properly"
              docker compose -f docker-compose.prod.yml logs --tail=50
              exit 1
            fi
          ENDSSH

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ API
          echo "üîå Checking API health endpoint..."
          API_HEALTH_URL="${API_URL}/api/health"
          MAX_RETRIES=15
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s "$API_HEALTH_URL" > /dev/null 2>&1; then
              echo "‚úÖ API health check passed"
              curl -s "$API_HEALTH_URL" || echo "Health check response received"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for API... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 3
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå API health check failed"
            exit 1
          fi

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
          echo "üåê Checking frontend..."
          MAX_RETRIES=10
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f -s "$FRONTEND_URL" > /dev/null 2>&1; then
              echo "‚úÖ Frontend is accessible"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for frontend... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 3
          done

          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è Frontend check failed (non-critical)"
          fi

      - name: Deployment summary
        if: always()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Author** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Time** | $(date -u +'%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ **Deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üåê **Frontend**: ${{ steps.urls.outputs.frontend_url }}" >> $GITHUB_STEP_SUMMARY
            echo "üîå **API**: ${{ steps.urls.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Rollback on failure
        if: failure()
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_SSH_PORT: ${{ steps.ssh_port.outputs.port }}
        run: |
          echo "‚ö†Ô∏è Deployment failed. Attempting rollback..."
          ssh -p $VPS_SSH_PORT $VPS_USER@$VPS_HOST << 'ENDSSH' || true
            cd ${{ env.DEPLOY_PATH }}
            echo "üîÑ Rolling back to previous commit..."
            git reset --hard HEAD~1 || git reset --hard origin/${{ github.ref_name }} || true
            echo "üî® Rebuilding containers..."
            docker compose -f docker-compose.prod.yml up -d --build || true
            echo "‚úÖ Rollback completed"
          ENDSSH

  # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Deployment notification
        run: |
          STATUS="${{ needs.deploy.result }}"
          EMOJI="‚úÖ"
          if [ "$STATUS" != "success" ]; then
            EMOJI="‚ùå"
          fi

          echo "$EMOJI Deployment $STATUS"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"

          # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –≤ Telegram, Slack, Email –∏ —Ç.–¥.
          # –ü—Ä–∏–º–µ—Ä –¥–ª—è Telegram:
          # curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
          #   -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
          #   -d "text=$EMOJI Deployment $STATUS%0ABranch: ${{ github.ref_name }}%0ACommit: ${{ github.sha }}"
